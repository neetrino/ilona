---
description: –ü—Ä–∞–≤–∏–ª–∞ –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏. Timeouts, retries, graceful shutdown, fault tolerance.
globs: ["**/*.ts", "**/api/**", "**/server/**"]
alwaysApply: false
---

# –ü–†–ê–í–ò–õ–ê –ù–ê–î–Å–ñ–ù–û–°–¢–ò

> –í—Å—ë –ª–æ–º–∞–µ—Ç—Å—è. –í–æ–ø—Ä–æ—Å –≤ —Ç–æ–º, –∫–∞–∫ —Å–∏—Å—Ç–µ–º–∞ –Ω–∞ —ç—Ç–æ —Ä–µ–∞–≥–∏—Ä—É–µ—Ç.

---

## üéØ –ì–õ–ê–í–ù–´–ï –ü–†–ò–ù–¶–ò–ü–´

1. **Fail Fast** ‚Äî –Ω–µ –∂–¥–∏ –≤–µ—á–Ω–æ, —Å—Ç–∞–≤—å —Ç–∞–π–º–∞—É—Ç—ã
2. **Graceful Degradation** ‚Äî —Ä–∞–±–æ—Ç–∞–π –¥–∞–∂–µ –ø—Ä–∏ —á–∞—Å—Ç–∏—á–Ω—ã—Ö –æ—Ç–∫–∞–∑–∞—Ö
3. **Retry with Backoff** ‚Äî –ø–æ–≤—Ç–æ—Ä—è–π —É–º–Ω–æ, –Ω–µ DDoS-—å
4. **Circuit Breaker** ‚Äî –∑–∞—â–∏—â–∞–π –æ—Ç –∫–∞—Å–∫–∞–¥–Ω—ã—Ö —Å–±–æ–µ–≤

---

## ‚è±Ô∏è TIMEOUTS

### –ü—Ä–∞–≤–∏–ª–∞ —Ç–∞–π–º–∞—É—Ç–æ–≤

```typescript
// ‚úÖ –í–°–ï–ì–î–ê —Å—Ç–∞–≤—å —Ç–∞–π–º–∞—É—Ç—ã –Ω–∞ –≤–Ω–µ—à–Ω–∏–µ –≤—ã–∑–æ–≤—ã

// HTTP –∑–∞–ø—Ä–æ—Å—ã
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch(url, {
    signal: controller.signal,
  });
} finally {
  clearTimeout(timeout);
}

// –ò–ª–∏ —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π
import ky from 'ky';

const api = ky.create({
  timeout: 10000, // 10 —Å–µ–∫—É–Ω–¥
  retry: {
    limit: 2,
    methods: ['get'],
    statusCodes: [408, 502, 503, 504],
  },
});
```

### –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ç–∞–π–º–∞—É—Ç—ã

| –û–ø–µ—Ä–∞—Ü–∏—è | Timeout | –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ |
|----------|---------|------------|
| API call (–≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π) | 5-10s | –ú–µ–∂–¥—É —Å–≤–æ–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏ |
| API call (–≤–Ω–µ—à–Ω–∏–π) | 10-30s | –°—Ç–æ—Ä–æ–Ω–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã |
| Database query | 5-30s | –ó–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ |
| File upload | 60-300s | –ó–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ |
| Payment processing | 30-60s | –ö—Ä–∏—Ç–∏—á–Ω–æ, —Å retry |

### –¢–∞–π–º–∞—É—Ç—ã –≤ Prisma

```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// –í connection string
// ?connection_limit=10&connect_timeout=10&pool_timeout=10

// –ò–ª–∏ –≤ –∫–æ–¥–µ
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
});

// Transaction timeout
await prisma.$transaction(
  async (tx) => {
    // operations
  },
  {
    maxWait: 5000,  // –ñ–¥–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
    timeout: 10000, // Timeout —Å–∞–º–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
  }
);
```

---

## üîÑ RETRY STRATEGIES

### Exponential Backoff

```typescript
// lib/utils/retry.ts

interface RetryConfig {
  maxRetries: number;
  baseDelay: number;    // ms
  maxDelay: number;     // ms
  backoffFactor: number;
  jitter: boolean;
  retryCondition?: (error: Error) => boolean;
}

const DEFAULT_CONFIG: RetryConfig = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 30000,
  backoffFactor: 2,
  jitter: true,
};

export async function withRetry<T>(
  fn: () => Promise<T>,
  config: Partial<RetryConfig> = {}
): Promise<T> {
  const {
    maxRetries,
    baseDelay,
    maxDelay,
    backoffFactor,
    jitter,
    retryCondition,
  } = { ...DEFAULT_CONFIG, ...config };

  let lastError: Error;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω—É–∂–Ω–æ –ª–∏ —Ä–µ—Ç—Ä–∞–∏—Ç—å
      if (retryCondition && !retryCondition(lastError)) {
        throw lastError;
      }

      // –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ ‚Äî –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É
      if (attempt === maxRetries) {
        throw lastError;
      }

      // –í—ã—á–∏—Å–ª—è–µ–º delay
      let delay = Math.min(
        baseDelay * Math.pow(backoffFactor, attempt),
        maxDelay
      );

      // –î–æ–±–∞–≤–ª—è–µ–º jitter (¬±10%)
      if (jitter) {
        const jitterAmount = delay * 0.1;
        delay += Math.random() * jitterAmount * 2 - jitterAmount;
      }

      console.log(
        `Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`
      );

      await sleep(delay);
    }
  }

  throw lastError!;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

```typescript
// –ü—Ä–æ—Å—Ç–æ–π —Ä–µ—Ç—Ä–∞–π
const data = await withRetry(() => fetchData(url));

// –° –∫–∞—Å—Ç–æ–º–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
const data = await withRetry(
  () => processPayment(orderId),
  {
    maxRetries: 5,
    baseDelay: 2000,
    retryCondition: (error) => {
      // –†–µ—Ç—Ä–∞–∏–º —Ç–æ–ª—å–∫–æ –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏
      if (error instanceof ApiError) {
        return error.statusCode >= 500 || error.statusCode === 429;
      }
      return true;
    },
  }
);
```

### –ö–æ–≥–¥–∞ –ù–ï —Ä–µ—Ç—Ä–∞–∏—Ç—å

```typescript
// ‚ùå –ù–ï —Ä–µ—Ç—Ä–∞–∏—Ç—å:
// - 4xx –æ—à–∏–±–∫–∏ (–∫—Ä–æ–º–µ 429, 408)
// - Validation errors
// - Auth errors (401, 403)
// - Business logic errors

const retryableStatuses = new Set([408, 429, 500, 502, 503, 504]);

const shouldRetry = (error: ApiError): boolean => {
  return retryableStatuses.has(error.statusCode);
};
```

---

## üîå CIRCUIT BREAKER

### –ü–∞—Ç—Ç–µ—Ä–Ω Circuit Breaker

```typescript
// lib/utils/circuit-breaker.ts

enum CircuitState {
  CLOSED = 'CLOSED',   // –ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞
  OPEN = 'OPEN',       // –ë–ª–æ–∫–∏—Ä—É–µ–º –≤—ã–∑–æ–≤—ã
  HALF_OPEN = 'HALF_OPEN', // –ü—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
}

interface CircuitBreakerConfig {
  failureThreshold: number;  // –°–∫–æ–ª—å–∫–æ –æ—à–∏–±–æ–∫ –¥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è
  successThreshold: number;  // –°–∫–æ–ª—å–∫–æ —É—Å–ø–µ—Ö–æ–≤ –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è
  timeout: number;           // –í—Ä–µ–º—è –≤ OPEN —Å–æ—Å—Ç–æ—è–Ω–∏–∏ (ms)
}

export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failures: number = 0;
  private successes: number = 0;
  private lastFailureTime?: number;

  constructor(
    private readonly name: string,
    private readonly config: CircuitBreakerConfig = {
      failureThreshold: 5,
      successThreshold: 2,
      timeout: 30000,
    }
  ) {}

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    if (this.state === CircuitState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new CircuitOpenError(this.name);
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failures = 0;

    if (this.state === CircuitState.HALF_OPEN) {
      this.successes++;
      if (this.successes >= this.config.successThreshold) {
        this.state = CircuitState.CLOSED;
        this.successes = 0;
        console.log(`Circuit ${this.name} CLOSED`);
      }
    }
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();

    if (this.state === CircuitState.HALF_OPEN) {
      this.state = CircuitState.OPEN;
      this.successes = 0;
      console.log(`Circuit ${this.name} OPEN (from HALF_OPEN)`);
    } else if (this.failures >= this.config.failureThreshold) {
      this.state = CircuitState.OPEN;
      console.log(`Circuit ${this.name} OPEN`);
    }
  }

  private shouldAttemptReset(): boolean {
    return (
      this.lastFailureTime !== undefined &&
      Date.now() - this.lastFailureTime >= this.config.timeout
    );
  }

  getState(): CircuitState {
    return this.state;
  }
}

class CircuitOpenError extends Error {
  constructor(circuitName: string) {
    super(`Circuit breaker "${circuitName}" is OPEN`);
    this.name = 'CircuitOpenError';
  }
}
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

```typescript
// –°–æ–∑–¥–∞—ë–º circuit breaker –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–Ω–µ—à–Ω–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
const paymentCircuit = new CircuitBreaker('payment-service', {
  failureThreshold: 3,
  successThreshold: 2,
  timeout: 60000,
});

async function processPayment(orderId: string) {
  return paymentCircuit.execute(async () => {
    return await paymentApi.charge(orderId);
  });
}

// –ü—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–æ–º circuit ‚Äî graceful degradation
try {
  await processPayment(orderId);
} catch (error) {
  if (error instanceof CircuitOpenError) {
    // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å
    await queuePaymentForLater(orderId);
    return { status: 'queued' };
  }
  throw error;
}
```

---

## üõë GRACEFUL SHUTDOWN

### Node.js Graceful Shutdown

```typescript
// main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule);

  // –í–∫–ª—é—á–∞–µ–º shutdown hooks
  app.enableShutdownHooks();

  // Graceful shutdown –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
  const shutdown = async (signal: string) => {
    logger.log(`Received ${signal}. Starting graceful shutdown...`);

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –Ω–∞ shutdown
    const shutdownTimeout = setTimeout(() => {
      logger.error('Shutdown timeout exceeded, forcing exit');
      process.exit(1);
    }, 30000);

    try {
      // –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ (NestJS —Å–∞–º –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç)
      await app.close();
      logger.log('Application closed successfully');
      clearTimeout(shutdownTimeout);
      process.exit(0);
    } catch (error) {
      logger.error('Error during shutdown', error);
      clearTimeout(shutdownTimeout);
      process.exit(1);
    }
  };

  // –°–ª—É—à–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã
  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));

  await app.listen(3000);
  logger.log('Application started on port 3000');
}

bootstrap();
```

### OnModuleDestroy –¥–ª—è cleanup

```typescript
// services/database.service.ts
import { Injectable, OnModuleDestroy, Logger } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleDestroy {
  private readonly logger = new Logger(PrismaService.name);

  async onModuleDestroy() {
    this.logger.log('Disconnecting from database...');
    await this.$disconnect();
    this.logger.log('Database disconnected');
  }
}

// services/redis.service.ts
@Injectable()
export class RedisService implements OnModuleDestroy {
  private readonly logger = new Logger(RedisService.name);

  async onModuleDestroy() {
    this.logger.log('Closing Redis connection...');
    await this.redis.quit();
    this.logger.log('Redis disconnected');
  }
}
```

### Kubernetes Readiness/Liveness

```typescript
// health/health.controller.ts
@Controller('health')
export class HealthController {
  constructor(private readonly health: HealthCheckService) {}

  // Liveness ‚Äî –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∂–∏–≤–æ?
  @Get('live')
  @HealthCheck()
  liveness() {
    return { status: 'ok' };
  }

  // Readiness ‚Äî –≥–æ—Ç–æ–≤–æ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ç—Ä–∞—Ñ–∏–∫?
  @Get('ready')
  @HealthCheck()
  readiness() {
    return this.health.check([
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ë–î
      () => this.db.pingCheck('database'),
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º Redis
      () => this.redis.pingCheck('redis'),
    ]);
  }
}
```

---

## üî• FAULT TOLERANCE PATTERNS

### Fallback

```typescript
// –ü—Ä–∏ –æ—à–∏–±–∫–µ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback
async function getProductRecommendations(userId: string): Promise<Product[]> {
  try {
    return await recommendationService.getPersonalized(userId);
  } catch (error) {
    logger.warn('Recommendation service failed, using fallback', { userId });
    // Fallback –Ω–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
    return await productService.getPopular();
  }
}
```

### Bulkhead (–∏–∑–æ–ª—è—Ü–∏—è)

```typescript
// –ò–∑–æ–ª–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
import PQueue from 'p-queue';

// –û—Ç–¥–µ–ª—å–Ω—ã–µ –æ—á–µ—Ä–µ–¥–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ–ø–µ—Ä–∞—Ü–∏–π
const paymentQueue = new PQueue({ concurrency: 10 });
const emailQueue = new PQueue({ concurrency: 5 });
const analyticsQueue = new PQueue({ concurrency: 20 });

// –ö—Ä–∏—Ç–∏—á–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—Ç—Å—è –Ω–µ-–∫—Ä–∏—Ç–∏—á–Ω—ã–º–∏
await paymentQueue.add(() => processPayment(order));
emailQueue.add(() => sendConfirmationEmail(order));  // –ù–µ –∂–¥—ë–º
analyticsQueue.add(() => trackPurchase(order));      // –ù–µ –∂–¥—ë–º
```

### Rate Limiting (Client Side)

```typescript
import Bottleneck from 'bottleneck';

// –õ–∏–º–∏—Ç–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å—ã –∫ –≤–Ω–µ—à–Ω–µ–º—É API
const limiter = new Bottleneck({
  maxConcurrent: 5,      // –ú–∞–∫—Å–∏–º—É–º 5 –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö
  minTime: 100,          // –ú–∏–Ω–∏–º—É–º 100ms –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
  reservoir: 100,        // 100 –∑–∞–ø—Ä–æ—Å–æ–≤
  reservoirRefreshAmount: 100,
  reservoirRefreshInterval: 60 * 1000, // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
});

const response = await limiter.schedule(() => 
  externalApi.call(data)
);
```

---

## üìã CHECKLIST

### Timeouts

- [ ] –í—Å–µ –≤–Ω–µ—à–Ω–∏–µ –≤—ã–∑–æ–≤—ã –∏–º–µ—é—Ç —Ç–∞–π–º–∞—É—Ç—ã
- [ ] Database queries —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏
- [ ] HTTP requests —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏
- [ ] –¢–∞–π–º–∞—É—Ç—ã –∞–¥–µ–∫–≤–∞—Ç–Ω—ã –æ–ø–µ—Ä–∞—Ü–∏—è–º

### Retries

- [ ] Exponential backoff –¥–ª—è —Ä–µ—Ç—Ä–∞–µ–≤
- [ ] Jitter –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è thundering herd
- [ ] –†–µ—Ç—Ä–∞–π —Ç–æ–ª—å–∫–æ –¥–ª—è recoverable –æ—à–∏–±–æ–∫
- [ ] –õ–∏–º–∏—Ç –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Ç—Ä–∞–µ–≤

### Graceful Shutdown

- [ ] –û–±—Ä–∞–±–æ—Ç–∫–∞ SIGTERM/SIGINT
- [ ] –ó–∞–∫—Ä—ã—Ç–∏–µ database connections
- [ ] –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö requests
- [ ] Timeout –Ω–∞ shutdown

### Fault Tolerance

- [ ] Circuit breakers –¥–ª—è –≤–Ω–µ—à–Ω–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
- [ ] Fallbacks –¥–ª—è non-critical features
- [ ] Health checks (liveness/readiness)
- [ ] Rate limiting –¥–ª—è –∑–∞—â–∏—Ç—ã

---

**–í–µ—Ä—Å–∏—è:** 1.0
**–î–∞—Ç–∞:** 2025-01-31
