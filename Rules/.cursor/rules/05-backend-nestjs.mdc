---
description: –ü—Ä–∞–≤–∏–ª–∞ Backend –∏ NestJS. –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ —Å–µ—Ä–≤–µ—Ä–Ω–æ–º—É –∫–æ–¥—É –∏ API.
globs: ["**/api/**", "**/server/**", "**/backend/**", "**/*.service.ts", "**/*.controller.ts", "**/*.module.ts"]
alwaysApply: false
---

# –ü–†–ê–í–ò–õ–ê BACKEND –ò NESTJS

> –ß–∏—Å—Ç–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞, —Ç–æ–Ω–∫–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã, —Ç–æ–ª—Å—Ç—ã–µ —Å–µ—Ä–≤–∏—Å—ã.

---

## üéØ –ì–õ–ê–í–ù–´–ï –ü–†–ò–ù–¶–ò–ü–´

1. **–ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã —Ç–æ–Ω–∫–∏–µ** ‚Äî —Ç–æ–ª—å–∫–æ —Ä–æ—É—Ç–∏–Ω–≥ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è
2. **–°–µ—Ä–≤–∏—Å—ã —Å–æ–¥–µ—Ä–∂–∞—Ç –ª–æ–≥–∏–∫—É** ‚Äî –≤—Å—è –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ –∑–¥–µ—Å—å
3. **Dependency Injection** ‚Äî –≤—Å—ë —á–µ—Ä–µ–∑ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
4. **DTO –¥–ª—è –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö** ‚Äî –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ –≤—Ö–æ–¥–µ

---

## üìÅ –°–¢–†–£–ö–¢–£–†–ê –ú–û–î–£–õ–Ø

### –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ NestJS –º–æ–¥—É–ª—è

```
src/
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ products.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.service.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ products-search.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-product.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ update-product.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ product-query.dto.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ product.entity.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ product.interface.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.module.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ orders/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îú‚îÄ‚îÄ decorators/
‚îÇ   ‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îú‚îÄ‚îÄ interceptors/
‚îÇ   ‚îú‚îÄ‚îÄ filters/
‚îÇ   ‚îú‚îÄ‚îÄ pipes/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ configuration.ts
‚îÇ
‚îî‚îÄ‚îÄ main.ts
```

---

## üéÆ –ö–û–ù–¢–†–û–õ–õ–ï–†–´

### –¢–æ–Ω–∫–∏–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä (–ø—Ä–∞–≤–∏–ª—å–Ω–æ)

```typescript
// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–æ—É—Ç–∏–Ω–≥–∞
@Controller('products')
@ApiTags('products')
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Get()
  @ApiOperation({ summary: '–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤' })
  async findAll(
    @Query() query: ProductQueryDto
  ): Promise<PaginatedResponse<Product>> {
    return this.productsService.findAll(query);
  }

  @Get(':id')
  @ApiOperation({ summary: '–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ ID' })
  async findOne(
    @Param('id', ParseUUIDPipe) id: string
  ): Promise<Product> {
    return this.productsService.findOne(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  @ApiOperation({ summary: '–°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç' })
  async create(
    @Body() dto: CreateProductDto,
    @CurrentUser() user: User
  ): Promise<Product> {
    return this.productsService.create(dto, user);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  async update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateProductDto
  ): Promise<Product> {
    return this.productsService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  @HttpCode(HttpStatus.NO_CONTENT)
  async remove(
    @Param('id', ParseUUIDPipe) id: string
  ): Promise<void> {
    await this.productsService.remove(id);
  }
}
```

### –¢–æ–ª—Å—Ç—ã–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä (–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ)

```typescript
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –ª–æ–≥–∏–∫–∞ –≤ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ
@Controller('products')
export class ProductsController {
  constructor(private readonly prisma: PrismaService) {}

  @Get()
  async findAll(@Query() query: any) {
    // ‚ùå –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –ë–î
    const products = await this.prisma.product.findMany({
      where: {
        isActive: true,
        category: query.category,
      },
      // ‚ùå –õ–æ–≥–∏–∫–∞ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –≤ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ
      skip: (query.page - 1) * query.limit,
      take: query.limit,
    });
    
    // ‚ùå –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ
    return products.map(p => ({
      ...p,
      priceFormatted: `${p.price} ‚ÇΩ`,
    }));
  }
}
```

---

## ‚öôÔ∏è –°–ï–†–í–ò–°–´

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–µ—Ä–≤–∏—Å–∞

```typescript
@Injectable()
export class ProductsService {
  private readonly logger = new Logger(ProductsService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly cacheService: CacheService,
    private readonly searchService: SearchService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  // –ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã ‚Äî –±–∏–∑–Ω–µ—Å-–æ–ø–µ—Ä–∞—Ü–∏–∏
  async findAll(query: ProductQueryDto): Promise<PaginatedResponse<Product>> {
    const { page = 1, limit = 20, category, search } = query;
    
    const where = this.buildWhereClause(query);
    
    const [items, total] = await Promise.all([
      this.prisma.product.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.product.count({ where }),
    ]);

    return {
      items,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string): Promise<Product> {
    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    const cached = await this.cacheService.get<Product>(`product:${id}`);
    if (cached) return cached;

    const product = await this.prisma.product.findUnique({
      where: { id },
      include: { category: true, variants: true },
    });

    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // –ö—ç—à–∏—Ä—É–µ–º
    await this.cacheService.set(`product:${id}`, product, 3600);

    return product;
  }

  async create(dto: CreateProductDto, user: User): Promise<Product> {
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –±–∏–∑–Ω–µ—Å-–ø—Ä–∞–≤–∏–ª
    await this.validateCategory(dto.categoryId);
    
    const product = await this.prisma.product.create({
      data: {
        ...dto,
        createdBy: user.id,
      },
    });

    // –ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞
    await this.searchService.index('products', product);
    
    // –°–æ–±—ã—Ç–∏–µ
    this.eventEmitter.emit('product.created', { product, user });
    
    this.logger.log(`Product created: ${product.id} by user ${user.id}`);

    return product;
  }

  async update(id: string, dto: UpdateProductDto): Promise<Product> {
    await this.findOne(id); // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    
    const product = await this.prisma.product.update({
      where: { id },
      data: dto,
    });

    // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫—ç—à
    await this.cacheService.del(`product:${id}`);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å
    await this.searchService.update('products', product);
    
    this.eventEmitter.emit('product.updated', { product });

    return product;
  }

  async remove(id: string): Promise<void> {
    await this.findOne(id);
    
    await this.prisma.product.delete({ where: { id } });
    
    await this.cacheService.del(`product:${id}`);
    await this.searchService.remove('products', id);
    
    this.eventEmitter.emit('product.deleted', { id });
  }

  // –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã ‚Äî –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
  private buildWhereClause(query: ProductQueryDto): Prisma.ProductWhereInput {
    const where: Prisma.ProductWhereInput = {
      isActive: true,
    };

    if (query.category) {
      where.categoryId = query.category;
    }

    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { description: { contains: query.search, mode: 'insensitive' } },
      ];
    }

    if (query.minPrice !== undefined || query.maxPrice !== undefined) {
      where.price = {};
      if (query.minPrice !== undefined) where.price.gte = query.minPrice;
      if (query.maxPrice !== undefined) where.price.lte = query.maxPrice;
    }

    return where;
  }

  private async validateCategory(categoryId: string): Promise<void> {
    const category = await this.prisma.category.findUnique({
      where: { id: categoryId },
    });
    
    if (!category) {
      throw new BadRequestException(`Category ${categoryId} not found`);
    }
  }
}
```

---

## üìù DTO (Data Transfer Objects)

### –ü—Ä–∞–≤–∏–ª–∞ DTO

```typescript
// dto/create-product.dto.ts
import { IsString, IsNumber, IsOptional, IsUUID, Min, MaxLength } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateProductDto {
  @ApiProperty({ description: '–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∞', example: 'iPhone 15' })
  @IsString()
  @MaxLength(255)
  name: string;

  @ApiPropertyOptional({ description: '–û–ø–∏—Å–∞–Ω–∏–µ', example: '–ù–æ–≤—ã–π iPhone...' })
  @IsOptional()
  @IsString()
  @MaxLength(5000)
  description?: string;

  @ApiProperty({ description: '–¶–µ–Ω–∞ –≤ –∫–æ–ø–µ–π–∫–∞—Ö', example: 99900 })
  @IsNumber()
  @Min(0)
  price: number;

  @ApiProperty({ description: 'ID –∫–∞—Ç–µ–≥–æ—Ä–∏–∏' })
  @IsUUID()
  categoryId: string;

  @ApiPropertyOptional({ description: 'SKU', example: 'IPHONE-15-128' })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  sku?: string;
}

// dto/update-product.dto.ts
import { PartialType } from '@nestjs/swagger';

export class UpdateProductDto extends PartialType(CreateProductDto) {}

// dto/product-query.dto.ts
export class ProductQueryDto {
  @ApiPropertyOptional({ default: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ default: 20, maximum: 100 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 20;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsUUID()
  category?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  minPrice?: number;

  @ApiPropertyOptional()
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  maxPrice?: number;
}
```

---

## üõ°Ô∏è GUARDS –ò MIDDLEWARE

### Auth Guard

```typescript
// common/guards/jwt-auth.guard.ts
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    return super.canActivate(context);
  }

  handleRequest<TUser = User>(err: any, user: TUser): TUser {
    if (err || !user) {
      throw new UnauthorizedException('Invalid or expired token');
    }
    return user;
  }
}

// common/guards/roles.guard.ts
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) return true;

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return requiredRoles.some(role => user.roles?.includes(role));
  }
}
```

### Custom Decorators

```typescript
// common/decorators/current-user.decorator.ts
export const CurrentUser = createParamDecorator(
  (data: keyof User | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;
    return data ? user?.[data] : user;
  },
);

// common/decorators/roles.decorator.ts
export const Roles = (...roles: string[]) => SetMetadata('roles', roles);

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
@Get('profile')
@UseGuards(JwtAuthGuard)
getProfile(@CurrentUser() user: User) {
  return user;
}

@Post()
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('admin')
create(@Body() dto: CreateDto) { ... }
```

---

## ‚ö†Ô∏è –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö

### Exception Filter

```typescript
// common/filters/http-exception.filter.ts
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const { status, message, errors } = this.getErrorDetails(exception);

    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message,
      ...(errors && { errors }),
    };

    this.logger.error(
      `${request.method} ${request.url} - ${status}`,
      exception instanceof Error ? exception.stack : undefined,
    );

    response.status(status).json(errorResponse);
  }

  private getErrorDetails(exception: unknown) {
    if (exception instanceof HttpException) {
      const response = exception.getResponse();
      return {
        status: exception.getStatus(),
        message: typeof response === 'string' 
          ? response 
          : (response as any).message,
        errors: (response as any).errors,
      };
    }

    if (exception instanceof Prisma.PrismaClientKnownRequestError) {
      return this.handlePrismaError(exception);
    }

    return {
      status: HttpStatus.INTERNAL_SERVER_ERROR,
      message: 'Internal server error',
    };
  }

  private handlePrismaError(error: Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        return { status: 409, message: 'Resource already exists' };
      case 'P2025':
        return { status: 404, message: 'Resource not found' };
      default:
        return { status: 500, message: 'Database error' };
    }
  }
}
```

### Business Exceptions

```typescript
// common/exceptions/business.exception.ts
export class BusinessException extends HttpException {
  constructor(
    message: string,
    public readonly code: string,
    statusCode: number = HttpStatus.BAD_REQUEST,
  ) {
    super({ message, code }, statusCode);
  }
}

export class InsufficientStockException extends BusinessException {
  constructor(productId: string, requested: number, available: number) {
    super(
      `Insufficient stock for product ${productId}. Requested: ${requested}, Available: ${available}`,
      'INSUFFICIENT_STOCK',
    );
  }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
if (variant.stock < quantity) {
  throw new InsufficientStockException(productId, quantity, variant.stock);
}
```

---

## üìä –õ–û–ì–ò–†–û–í–ê–ù–ò–ï

```typescript
// –ò—Å–ø–æ–ª—å–∑—É–π –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π Logger
@Injectable()
export class OrdersService {
  private readonly logger = new Logger(OrdersService.name);

  async create(dto: CreateOrderDto): Promise<Order> {
    this.logger.log(`Creating order for user ${dto.userId}`);
    
    try {
      const order = await this.processOrder(dto);
      this.logger.log(`Order created: ${order.id}`);
      return order;
    } catch (error) {
      this.logger.error(`Failed to create order: ${error.message}`, error.stack);
      throw error;
    }
  }
}
```

---

## üìã CHECKLIST

### –ú–æ–¥—É–ª—å

- [ ] –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Ç–æ–Ω–∫–∏–π (—Ç–æ–ª—å–∫–æ —Ä–æ—É—Ç–∏–Ω–≥)
- [ ] –°–µ—Ä–≤–∏—Å —Å–æ–¥–µ—Ä–∂–∏—Ç –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫—É
- [ ] DTO —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
- [ ] Swagger –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
- [ ] Guards –¥–ª—è –∑–∞—â–∏—Ç—ã —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
- [ ] –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
- [ ] –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∞–∂–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π

---

**–í–µ—Ä—Å–∏—è:** 1.0
**–î–∞—Ç–∞:** 2025-01-31
